= Clojure made easy
:copyright: Yehonathan Sharvit
:license: Eclipse Public License http://www.eclipse.org/legal/epl-v10.html
include::slide.attrs[]


[state=title]
== Clojure made easy

[.hidden]
--
[source.eval-clojure, clojure]
(ns fun.clj
(:require
        [clojure.string :refer [join upper-case]]
        [clojure.test 
           :refer-macros [deftest is are]]))
--

[NOTE.speaker]
This text will only show in the speaker view mode.


== Begin with the End in Mind

. You are motivated to learn Clojure
. You look differently at your existing Software knowledge 
. You had a fun evening
. You want to read my book on Clojure

== Three key ideas

[%step]
. The power of expressions
. Separate side effects from computation
. Dealing with data is valuable
. Pure functions are helpful
. Macros are awesome




== Hello Clojure

++++
<br><br>
++++
[quote]
--
Challenge 1 +

Write a function that receives a `name` and prints to the console +
Hello <name>! +

_You may use the language of your choice._
--

== Hello Clojure
[.fragment]
--
We create a function named `hello` that receives `name` +
and returns the concatenation of `"Hello"` and `name`
[source.eval-clojure, clojure]
(defn hello [name]
  (str "Hello, " name "!"))
--

[.fragment]
--
We call the `hello` function with `"Clojure"` as an argument
[source.eval-clojure, clojure]
(hello "Clojure")
--

[.fragment]
--
We print the return value of `(hello "Clojure")`
[source.eval-clojure, clojure]
(println (hello "Clojure"))
--


== Pure functions vs. side effects

[fragment]
--
A *pure* function
[.centered]
image::hello.png[width=65%]
--

[fragment]
--
A function with *side effects*
[.centered]
image::println.png[width=65%]
--

== Key idea: separate side effects from computation

++++
<br><br>
++++
--
image::print-hello.png[]
--

== The value of pure functions

[%step]
. Testable
. Composable
. Cachable

== Testable

[fragment]
--
A trivial test case
[source.eval-clojure, clojure]
(deftest test-hello-clojure
   (is (= (hello "Clojure")
          "Hello, Clojure!"))) 
--

[fragment]
--
Check
[source.eval-clojure, clojure]
(test-hello-clojure)
--

[fragment]
--
ðŸ¤” Can you test the function you wrote to solve the challenge?
--


== Composable

[quote]
--
We can use our functions as building blocks ðŸ§±  for other functions.
--

[fragment]
--
[cols="1,2", frame=none, grid=none]
|===
|We compose as we wish
a|[source.eval-clojure, clojure]
(defn hello-cap [name]
  (upper-case (hello name)))

|===
--

[fragment]
--
[cols="1,2", frame=none, grid=none]
|===
|It returns a composed string
a|[source.eval-clojure, clojure]
(hello-cap "Clojure")
|===
--

[fragment]
--
[cols="1,2", frame=none, grid=none]
|===
|We print it, later
a|["Clojure" "Python" "Javascript" "Java"]
[source.eval-clojure, clojure]
(println (hello-cap "Clojure"))
|===
--

[fragment]
--
ðŸ¤” Can you compose the function you wrote without modifying its code?
--


== Hello worlds

Handle sequences
[.fragment]
--
Let's handle sequence of names
[source.eval-clojure, clojure, width=500]
(map hello ["Clojure" "Python" "Javascript" "Java"])
--

[.fragment]
--
[cols="1,2", frame=none, grid=none]
|===
|Let's combine the elements of the sequence, into a string
a|[source.eval-clojure, clojure]
(defn multiple-hellos [names]
  (join " " (map hello names)))
--

[.fragment]
--
We print, later
[source.eval-clojure, clojure]
(println (multiple-hellos ["Clojure" "Python" "Javascript" "Java"]))
--


== Cachable

[.fragment]
--
[cols="2"]
|===
|Imagine that string concatenation were a heavy operation.
a|[source.eval-clojure, clojure]
(defn hello-print [name]
  (println (str "Hello, " name "!")))
|===
--


[quote.fragment]
--
We would like to cache the function +
Next time we call it, it returns the result immediately 
--


[.fragment]
--
[cols="2"]
|===
|ðŸ¤ª  It makes no sense to cache a function with side effects!
a|[source.eval-clojure, clojure]
(def memoized-print (memoize println))
(memoized-print "Hello!")
(memoized-print "Hello!")
(memoized-print "Good bye!")
|===
--




  
== The lack of power of expressions

We cannot assign the result of an `if` statement to a variable.

We cannot comment out an expression.

The syntax is not uniform: operator, statements, function calls, function definition, classes...

== The power of expressions

[.fragment]
TIP: Every part of the language is an expression, with the same structure


[.fragment]
[cols="2*", frame=none, grid=none]
|===

a|[.fragment]
--
arithmetic operation
[source.eval-clojure, clojure]
(+ 1 2)
--

a|[.fragment]
--
boolean operation
[source.eval-clojure, clojure]
(and true false)
--

a|[.fragment]
--
local bindings
[source.eval-clojure, clojure]
(let [a 42])
--

a|[.fragment]
--
variable assignment
[source.eval-clojure, clojure]
(def my-num 42)
--

a|[.fragment]
--
`if` expression
[source.eval-clojure, clojure]
(if my-num "happy" "sad")
--

a|[.fragment]
--
function call
[source.eval-clojure, clojure]
(inc 42)
--

a|[.fragment]
--
function definition
[source.eval-clojure, clojure]
(defn add-42 [x]
  (+ x 42))
--
|===


== The power of expressions - Javascript vs. Clojure

|===

|Javascript|Clojure

a|
--
[source, javascript]
foo(1, 2)
--
a|
--
[source, clojure]
(foo 1 2)
--

a|
--
[source, javascript]
2 + 3
--
a|
--
[source, clojure]
(+ 2 3)
--

a|
--
[source, javascript]
if (x > 2) {
  return 3;
} else {
  return 5;
}
--
a|
--
[source, clojure]
(if (> x 2)
    3
    5)
--

a|
--
[source, javascript]
var myNum = 42
--
a|
--
[source, clojure]
(def my-num 42)
--
|===

== The power of expressions - the rules

[%step]
. An expression is enclosed into opening and closing parenthesis
. First element inside the parentheses is the name of the expression: `def`, `if`, `+`...
. Other elements inside the parentheses are the "arguments" to be passed to the expression, either a primitive or an expression
. When one of the "arguments" is itself an expression, it follows the same syntactic rules (recursively)


== The power of expressions - more examples

A table with:
simple expressions
nested expression

== The power of expressions - if expressions

We can assign the result of an `if` expression into a variable

[source.eval-clojure, clojure]
--
(def my-mood (if my-num "happy" "sad"))
my-mood
--

== The power of expressions - comments

We can comment out a single expression out of a big piece of code
[source.eval-clojure, clojure]
--
(defn print-moods [num]
  (println "happy")
  (if (= num 42)
    (println "furious")
    (println "angry"))
  (println "sad"))

(print-moods 42)
--



== Next

[source.eval-clojure, clojure]
(+ 1 2)

TIP: Why


The answer in the bottom box is evaluated immediately.


== JavaScript

[source.eval-javascript, javascript]
1 + 2

NOTE: Multiple languages are supported by Klipse


== HTML

[source.eval-html, html]
<svg>
  <circle fill="blue"
          r="20" cx="50" cy="50" />
  <circle fill="green"
          r="20" cx="200" cy="50" />
</svg>

TIP: Try changing one of the colors


== What is Klipse?

An interactive client-side code evaluator.

Turns `<pre><code> ... </code></pre>` snippets into a live editor,
with beautiful syntax highlighting.

Supports many languages.

Perfect for blogs... and slides!

See the https://github.com/viebel/klipse[Klipse github repo, role="external", window="_blank"].


== What is AsciiDoctor?

A powerful toolchain for publishing.

Better than markdown:

* Target multiple formats (html/pdf/book/slides)
* Tables, figures, tip/warn/note, table of contents

See https://asciidoctor.org/[Asciidoctor, role="external", window="_blank"] for more information.


== What is RevealJS?

A modern HTML slide presentation framework.

Features include:

* Speaker notes and full screen
* Transitions
* And much more

Read more on the https://revealjs.com/[RevealJS website, role="external", window="_blank"].

== Putting it all together...

This presentation is a template project for creating your own presentation.

Get the source:

https://github.com/timothypratley/asciidoctor-revealjs-klipse[asciidoctor-revealjs-klipse github repository, role="external", window="_blank"].
