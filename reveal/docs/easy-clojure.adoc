= Clojure made easy
:copyright: Yehonathan Sharvit
:license: Eclipse Public License http://www.eclipse.org/legal/epl-v10.html
include::slide.attrs[]


[state=title]
== Clojure made easy


[NOTE.speaker]
This text will only show in the speaker view mode.


== Begin with the End in Mind

. You are motivated to learn Clojure
. You look differently at your existing Software knowledge 
. You had a fun evening
. You want to read my book on Clojure

== Three key ideas

[%step]
. The power of expressions
. Separate side effects from computation
. Dealing with data is valuable
. Pure functions are helpful
. Macros are awesome




== Hello Clojure

[.fragment]
--
We create a function named `hello` that receives `name` +
and returns the concatenation of `"Hello"` and `name`
[source.eval-clojure, clojure]
(defn hello [name]
  (str "Hello, " name "!"))
--

[.fragment]
--
We call the `hello` function with `"Clojure"` as an argument
[source.eval-clojure, clojure]
(hello "Clojure")
--

[.fragment]
--
We print the return value of `(hello "Clojure")`
[source.eval-clojure, clojure]
(println (hello "Clojure"))
--


== Pure functions vs. side effects

[fragment]
--
A pure function

image::hello.png[height=250]
--

[fragment]
--
A function with side effects

image::println.png[height=320]
--

== Key idea: separate side effects from computation

--
image::print-hello.png[]
--

== Hello worlds
[.fragment]
[source.eval-clojure, clojure]
(defn multiple-hellos [names]
  (clojure.string/join "\n" (map hello names)))



(println (multiple-hellos ["Martin" "Bert"]))

== The lack of power of expressions

We cannot assign the result of an `if` statement to a variable.

We cannot comment out an expression.

The syntax is not uniform: operator, statements, function calls, function definition, classes...

== The power of expressions

[.fragment]
TIP: Every part of the language is an expression, with the same structure


[.fragment]
[cols="2*", frame=none, grid=none]
|===

a|[.fragment]
--
arithmetic operation
[source.eval-clojure, clojure]
(+ 1 2)
--

a|[.fragment]
--
boolean operation
[source.eval-clojure, clojure]
(and true false)
--

a|[.fragment]
--
namespace declaration
[source.eval-clojure, clojure]
(ns fun.clj)
--

a|[.fragment]
--
variable assignment
[source.eval-clojure, clojure]
(def my-num 42)
--

a|[.fragment]
--
`if` expression
[source.eval-clojure, clojure]
(if my-num "happy" "sad")
--

a|[.fragment]
--
function call
[source.eval-clojure, clojure]
(inc 42)
--

a|[.fragment]
--
function definition
[source.eval-clojure, clojure]
(defn add-42 [x]
  (+ x 42))
--
|===


== The power of expressions - Javascript vs. Clojure

|===

|Javascript|Clojure

a|
--
[source, javascript]
foo(1, 2)
--
a|
--
[source, clojure]
(foo 1 2)
--

a|
--
[source, javascript]
2 + 3
--
a|
--
[source, clojure]
(+ 2 3)
--

a|
--
[source, javascript]
if (x > 2) {
  return 3;
} else {
  return 5;
}
--
a|
--
[source, clojure]
(if (> x 2)
    3
    5)
--

a|
--
[source, javascript]
var myNum = 42
--
a|
--
[source, clojure]
(def my-num 42)
--
|===

== The power of expressions - the rules

[%step]
. An expression is enclosed into opening and closing parenthesis
. First element inside the parentheses is the name of the expression: `def`, `if`, `+`...
. Other elements inside the parentheses are the "arguments" to be passed to the expression, either a primitive or an expression
. When one of the "arguments" is itself an expression, it follows the same syntactic rules (recursively)


== The power of expressions - more examples

A table with:
simple expressions
nested expression

== The power of expressions - if expressions

We can assign the result of an `if` expression into a variable

[source.eval-clojure, clojure]
--
(def my-mood (if my-num "happy" "sad"))
my-mood
--

== The power of expressions - comments

We can comment out a single expression out of a big piece of code
[source.eval-clojure, clojure]
--
(defn print-moods [num]
  (println "happy")
  (if (= num 42)
    (println "furious")
    (println "angry"))
  (println "sad"))

(print-moods 42)
--



== Next

[source.eval-clojure, clojure]
(+ 1 2)

TIP: Why


The answer in the bottom box is evaluated immediately.


== JavaScript

[source.eval-javascript, javascript]
1 + 2

NOTE: Multiple languages are supported by Klipse


== HTML

[source.eval-html, html]
<svg>
  <circle fill="blue"
          r="20" cx="50" cy="50" />
  <circle fill="green"
          r="20" cx="200" cy="50" />
</svg>

TIP: Try changing one of the colors


== What is Klipse?

An interactive client-side code evaluator.

Turns `<pre><code> ... </code></pre>` snippets into a live editor,
with beautiful syntax highlighting.

Supports many languages.

Perfect for blogs... and slides!

See the https://github.com/viebel/klipse[Klipse github repo, role="external", window="_blank"].


== What is AsciiDoctor?

A powerful toolchain for publishing.

Better than markdown:

* Target multiple formats (html/pdf/book/slides)
* Tables, figures, tip/warn/note, table of contents

See https://asciidoctor.org/[Asciidoctor, role="external", window="_blank"] for more information.


== What is RevealJS?

A modern HTML slide presentation framework.

Features include:

* Speaker notes and full screen
* Transitions
* And much more

Read more on the https://revealjs.com/[RevealJS website, role="external", window="_blank"].

== Putting it all together...

This presentation is a template project for creating your own presentation.

Get the source:

https://github.com/timothypratley/asciidoctor-revealjs-klipse[asciidoctor-revealjs-klipse github repository, role="external", window="_blank"].
