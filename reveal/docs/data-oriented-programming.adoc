= Data oriented programming
include::slide.attrs[]

[state=title]
[%notitle]
== Data oriented programming

[.centered]
--
{bl}
{bl}
{bl}
{bl}
{bl}
{bl}
[..big-text]
*Data oriented programming*


_The secret ingredient that makes Clojure system less complex_


Yehonathan Sharvit
--


== Why we love Clojure


{bl}
{bl}
{bl}

image::clojure-essence.svg[width=100%]

{bl}

[.centered]
NOTE: *Complex* means: _hard to understand_

== {principle} Principles of Data Oriented programming

[.centered.bordered]
Data is a *first class citizen*

{bl}
{bl}

[.left.wsmall]
{bl}
[.fragment]
[.left.w50.bordered]
[%step]
. *Separate* Code from Data
. *Represent* records as maps
. Do not *mutate* data

[.left.wsmall]
{bl}
[.fragment]
[.left.w40.bordered]
* Language agnostic
** OO and FP
** Statically or dynamically typed
* Applicable in isolation
* Synergy



== üìöDesign a library management system


[.fragment]
[.left.w30]
image::watchmen-library.png[]

[.left.w10]
{bl}

[.fragment]
[.left.w30]
image::complex-class-relation.svg[width=100%]


[.fragment]
--
{meditation}What makes this system _complex_?
--

[.fragment]
* Nodes with many edges
* Many kind of arrows
** Association
** Composition
** Inheritance
** Usage

== {principle} Principle #1: Separate Code from Data

{bl}
{bl}

[.fragment]
[.centered]
image::principle1-nutshell.svg[width=100%]

[.fragment]
[.left.w50]
--
[source, javascript]
class Author {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  fullName() {
    return this.firstName + " "
               + this.lastName;
  }
}
--

[.fragment]
--
[.left.w50]
[source, javascript]
function createAuthorData(firstName, lastName) {
  return {
    firstName: firstName,
    lastName: lastName
  };
}
function fullName(data) {
  return data.firstName + " " +
  data.lastName;
}

--


=== {benefit}Reduction of System Complexity

[.fragment]
[.left.w20]
image::complex-class-relation.svg[]

[.fragment]
[.left.w50]
image::data-code-relation.svg[]


[.left]
[.fragment]
--
{meditation}What makes this system _less complex_?
--

* Separation of concerns
. Code diagram constraint
.. Stateless (static)
.. No inheritance
.. Only usage relation
. Data diagram constraint
.. Only association and composition
[.left.w20]
== {principle}Principle #2:Represent records as maps
image:data-building-blocks.svg[]

=== {benefit}Reduction of System Complexity even more

[.fragment]
[.left.w30]
image::data-code-relation.svg[]

[.fragment]
[.left.w60]
image::data-code-relation.svg[]


=== {benefit} Visualize the system data

image::library-data.svg[]


== {principle} Principle #3: Do not mutate Data

It's obvious!

image::https://i.imgflip.com/411lb0.png[]

== üë®‚ÄçüíªApplication of DO principles

{bl}
{bl}
{bl}
{bl}
{bl}

[.centered90]
image::application-do.svg[width=100%]

== ‚è≥Summary
image::do-principles-journey.svg[width=90%]

== üéπImagine

== Questions


[.left.w50]
image::questions.jpg[width=75%]

[.left.w50]

Data Oriented Programming book

https://tinyurl.com/dop-book[]


[.left.w20]
image::https://chart.googleapis.com/chart?cht=qr&chl=https://tinyletter.com/data-oriented-programming/subscribe&chs=400x400[]
