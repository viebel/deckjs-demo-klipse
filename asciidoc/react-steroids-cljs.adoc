= React on steroids with ClojureScript
:encoding: utf-8
:navigation:
:deckjs_transition: horizontal-slide
:menu:
:status:
:deckjs_theme: none
:hardbreaks:


++++
<pre class="hidden"><code class="clj">
(ns my.m$macros)
(require '[reagent.core :as r])
(require '[reagent.ratom :as ratom])

</code></pre>
++++


== Agenda

- ClojureScript: a pragmatic LISP
- Hiccup: HTML as data
- Reagent: an elegant ClojureScript interface to React
- Going further

== The Goal

- LISP is cool
- Power of expression
- Pragmatic Theoretic stuff 

== Who am I?
[.left]
--
- Yehonathan Sharvit https://twitter.com/viebel[@viebel]
- A mathematician
- A coder
- A pragmatic theorist
- A freak of interactivity
- Founded Audyx in 2013 - an Audiology Startup with 30K LOCs in Clojurescript
- Author of https://github.com/viebel/klipse[Klipse] - a simple client-side code evaluator pluggable on any web page 
++++
                      <a class="github-button" href="https://github.com/viebel/klipse" data-count-href="/viebel/klipse/stargazers" data-count-api="/repos/viebel/klipse#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star viebel/klipse on GitHub">KLIPSE</a>
                    <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
++++
- A Web consultant: Full-Stack, clojure, clojurescript, javascript, node.js, react
- Blogger about functional programming at http://blog.klipse.tech/[blog.klipse.tech]
--

image::https://pbs.twimg.com/profile_images/713278171353911296/1a2useM2.jpg[me]


== ClojureScript - historical perspective

* 1930: Alonzo Church discovers the  https://en.wikipedia.org/wiki/Lambda_calculus[Î»-calculus]
* 1958: John McCarthy invents https://en.wikipedia.org/wiki/Lisp_(programming_language)[LISP]
* 1995: Brendan Eich is recruited by Netscape to do "scheme in the browser"
* Eventually, he invents Javascript
* 2007 - Rich Hickey invents Clojure - A practical dialect of LISP on top of JVM
* 2011 - ClojureScript - Clojure rocks, Javascript reaches!
* 2013 - Facebook creates react.js - A functional javascript frontend framework
* Dec 2013 - First release of reagent - A react cljs interface that is faster than react!

== LISP

LISP is homoiconic: the syntax of the code is the same as the syntax of the data - lists.
LISP stands for LIst Processing.

Code is expressed as lists where:
- the first element of the list is the function
- rest of the list are the arguments to the function

Unlike in javacsript, every piece of LISP code is an expression (including `if`, `for` etc...).

== Clojure - functions

[%step]
--
Function definition:

[source, role="clj"]
----
(defn hello [name]
  (str "Hello " name "!"))
----
--

[%step]
--
Function application:

[source, role="clj"]
----
(hello "React Next")
----
--


== Interactivity

You can follow this presentation on your desktop, tablet, phone...
All the code snippets are interative!

++++
              <div class="left">
		<img src='https://chart.googleapis.com/chart?cht=qr&chl=http%3A%2F%2Fslides.klipse.tech%2Fasciidoc%2Freact-steroids-cljs.html&chs=300x300' alt='qr code'></img>
		<a style="font-size:3em;" href="https://tinyurl.com/introFP"> https://tinyurl.com/recljs </a>
	      </div>
++++

image::images/journey.jpg[journey,900]



== Clojure - Immutable data structures

[%step]
--
Data structures are immutable.
You cannot change an object.
You can only compute a new version of the object.
--

[%step]
--
[source.clj]
----
(def a {:hello "React"})
(assoc a :hello "Reagent")
----

[source.clj]
----
a
----
--

[%step]
--
The cool thing is that it is performant.
Read http://hypirion.com/musings/understanding-persistent-vector-pt-1[here] if you want to understand this magic.
--

== Immutability - why is it so good

[%step]
--
Simpler to reason.
Kills lots of bugs before they arise.
--

[%step]
--
Great performance in react-like apps (`shouldComponentUpdate`).
With immutable data, comparing two data structures is done via pointer comparison (recursively).
Actually, in many cases ClojureScript react apps are faster than javascript react apps.
--


== Clojure - atoms and mutations

[%step]
--
Mutations are achieved with a specific mechanism called `atom`.
The atom itself is not mutable but the "content" of the atom is mutable.
In order to get the "content" of an atom, you have to `deref` it.
--

[%step]
--
[source.clj]
----
(def a-atom (atom {:hello "React"}))
@a-atom
----
--



[%step]
--
Two ways to change the content of an atom: `reset!` and `swap!`:

[source.clj]
----
(reset! a-atom {:hello "Reagent"})
@a-atom
----
--

[%step]
--
[source.clj]
----
(swap! a-atom assoc :chalom "Next")
@a-atom
----
--


== Macros - the language itself is extensible

This is one of the most powerful feature of LISP languages.

[%step]
--
[source.clj]
----
(defmacro deflog [name args body]
  `(defn ~name ~args (println (str "LOG: "'~name " was called")) ~@body))
----
--

[%step]
--
Let's see it in action:
[source.clj]
----
(my.m/deflog hello-me [name]
  (str "hello " name))

(hello-me "React Next")
----

--
[%step]
Macros work particularly well in LISP because code is data (homoiconicity).
Therefore, manipulating code is usually a matter of list manipulation.
--
--
[%step]
--
Let's see it how the macro has been expanded:
[source.clj]
----
(macroexpand-1 '(my.m/deflog hello-me [name]
  (str "hello " name))) 
----
--

[%step]
--
- In fact, many terms of the language are just macros that a developer could have written: `for`, `when`, `->` ...
- If javascript had a macro system, it would have been much simpler to create JSX (or maybe a better solution)
--

== HICCUP - HTML as data

[%step]
--
Representing HTML in Clojure Data Structures:

- vectors to represent elements
- maps to represent an element's attributes
--

[%step]
--
[source.reagent]
----
[:div "Hello World"]
----
--

[%step]
--
[source.reagent]
----
[:p
 "Hello "
 [:a {:href "https://en.wikipedia.org/wiki/World"} "World"]
 "."]
----
--

[%step]
--
What about styles?
[source.reagent]
----
[:p 
 "Hello " 
 [:span {:style {:color "red"}} "World"]
 "."]
----
--

[%step]
--
Hiccup also supports shorthands for classes, ids and also element squeezing with `>`:
[source.reagent]
----
[:div#foo-12.supercool "My Div"]
----
[source.reagent]
----
[:div>p>s "Nested Element"]
----
--


== HICCUP - clean

Unlike with JSX,  you can use any construct of the language:

[%step]
--
[source.reagent]
----
[:ul
 (for [i (range 5)]
  (if (even? i)
    [:li i]))]
----
--


== Reagent - basic components

[%step]
Pure components are clojure functions


[%step]
--
[source.clj]
----
 (defn button [text]
  [:button
   {:on-click
    (fn [e]
      (js/alert "You pressed the button!"))}
   text])
----

We embed a component, like we embed html tags using the function name instead of a keyword:

--
[%step]   
--
[source.reagent]
----
[:div
 [:div "This is a button"]
 [button "Click me"]]
----
--

== Reagent - ratom and state

Ratom stands for reagent atom.
It has the same interface as a clojure atom: `reset!`, `swap!` and `@`.
Any component that dereferences a ratom will be automatically re-rendered.


[%step]
--
[source.clj]
----
(def counter (r/atom 0))
(defn button-inc [text]
  [:button
   {:on-click 
    (fn [e]
      (swap! counter inc))}
   text])
----


If we want the ratom to be local to the component, we have to instantiate the `ratom` inside the component and return a function instead of a hiccup form

[%step]
--
[source.clj]
----
(defn button-and-counter [text]
  (let [counter (r/atom 0)]
    (fn [text]
      [:div
       [:div "Counter: " @counter]
       [:button
        {:on-click
         (fn [e]
           (swap! counter inc))}
        text]])))
----
--

--
[%step]   
--
[source.reagent]
----
[button-and-counter "Click here"]
----
--

The rationale is:

- The outer function is called once *per component instance*.
- The inner function is called once *per rendering*.


More details about reagent components https://github.com/Day8/re-frame/wiki/Creating-Reagent-Components[here].

== Reagent - reactions

[%step]
--
Reactions allow you to define a `ratom` as an expression of other `ratom`s.

Let's say we have a growing list of numbers and we want 3 components presenting the same list:

- in its original order
- sorted
- reversly sorted
--

Let's create a `ratom` and a `reaction`:

[%step]
--
[source.clj]
----
(def numbers (r/atom (repeatedly 5 (partial rand-int 100))))
(def sorted-numbers (reagent.ratom/reaction (sort @numbers))) 
----
--

And now let's display the three components
[%step]
--
[source.reagent]
----
(defn sorted-d20 []
  [:div
   [:button {:on-click (fn [e] (swap! numbers conj (rand-int 20)))} "Roll!"]
   [:p (str @numbers)]
    [:p (str @sorted-numbers)]
    [:p (str (reverse @sorted-numbers))]])  
----
--

[%step]
--
How does this magic happen?
How could the reaction be re-calculated when the atom's value changes?
--


== Reagent - cool stuff


[%step]   
--
Let's draw a small logo in SVG:
[source.reagent]
----
(defn logo []
  (let [blue "#5881d8"
        green "#63b132"]
    [:svg {:style
           {:width "150px"}}
     [:circle {:r 50, :cx 75, :cy 75, :fill blue}]
     [:circle {:r 25, :cx 75, :cy 75, :fill green}]
     [:path {:stroke-width 12
             :stroke "white"
             :fill "none"
             :d "M 30,40 C 100,40 50,110 120,110"}]]))

----
--


[%step]   
--
Now, let's duplicate them:
[source.reagent]
----
[:span (repeat 5 [logo])]
----
--

== Going further

- https://github.com/Day8/re-frame[re-frame]: A Reagent Framework For Writing SPAs, in Clojurescript.
- https://github.com/omcljs/om/wiki/Quick-Start-%28om.next%29[om.next]: A  uniform yet extensible approach to building networked interactive applications, in Clojurescript.
- http://ramdajs.com/[Ramda.js]: A practical functional library for JavaScript programmers (inspired by Clojure).
- https://facebook.github.io/immutable-js/[Immutable.js]: Immutable collections for JavaScript (inspired by Clojure).
- http://redux.js.org/[Redux] - inspired by clojurescript and om
- https://www.sweetjs.org/[sweet.js] - bringing macros into the javascript world 


== More about ClojureScript

- http://clojurians.net/[Clojure Slack]
- http://clojurescriptkoans.com/[ClojureScript koans]: the path of enlightenment to learning ClojureScript
- https://clojuredocs.org/[ClojureDocs]: community-powered documentation and examples repository for Clojure
- http://app.klipse.tech/[Klipse]: a ClojureScript Web REPL



== Questions

image::images/questions.jpg[questions]



include::klipse.adoc[]