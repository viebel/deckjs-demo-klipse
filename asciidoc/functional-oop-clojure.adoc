= Polymorphism à la Clojure: "Functional Object Oriented Programming" is not an Oxymoron
:encoding: utf-8
:navigation:
:deckjs_transition: horizontal-slide
:menu:
:status:
:deckjs_theme: none
:hardbreaks:

++++
<pre class="hidden"><code class="clj">
(ns my.playground)
</code></pre>
++++


== Intro

++++
<section class="slide">
        <div class="text-centered">
            <div class="centered" style="font-size:1.9em;">
	    <br>
            <div> Polymorphism à la Clojure
    <br>
    <span style="font-style:italic;m">Functional Object Oriented Programming</span>
    <br>
    is not an Oxymoron
    </div>
              <div class="left" style="width:50%;">
	      <img src='https://chart.googleapis.com/chart?cht=qr&chl=http%3A%2F%2Fslides.klipse.tech%2Fasciidoc%2Ffunctional-oop-clojure.html&chs=300x300' alt='qr code'></img>
	      </div>
              <div class="left" style="width:50%;">
		<div>
                  <div>
                    <img class="fullscreen" src="./images/klipse.png" alt="" width="150">
                  </div> 
                  <div>
		  <div>ClojureX 2018</div>
		  <div>London - Dec 3, 2018</div>
                  </div>
                  <div class="clear">
                    <div style="margin-top:14px;">
		    <a class="github-button" href="https://github.com/viebel/klipse" data-size="large" data-show-count="true" aria-label="Star viebel/klipse on GitHub">Klipse</a>
                    </div>
                  </div>
                  <div>
		  <a href="https://tinyurl.com/fun-oop"> https://tinyurl.com/fun-oop </a>
                  </div>
		</div>
              </div>
            </div>
            <div class="clear centered">
	    <br><br><br>
	      <div style="padding-top: 20px;">
		<pre><code class="clj" data-loop-msec="1000" data-beautify-strings="true">
		(str (js/Date.))
		</code></pre>
		<br>
	      </div>
            </div>
	    <br><br>
	    <div style="font-size: 2em;">Yehonathan Sharvit</div>
	    <div style="font-size: 2em;"> <a href="https://twitter.com/viebel">@viebel</a>, viebel@gmail.com</div></p>
        </div>
      </section>
++++

== The Agenda

- Definitions and Rhetorics
- Object Oriented Programming with functions and maps
- Object Oriented Programming with records and protocols
- Conclusion

https://clojure.org/reference/datatypes#_deftype_and_defrecord

== Who am I?
[.left]
--
- Yehonathan Sharvit https://twitter.com/viebel[@viebel], viebel@gmail.com, https://www.linkedin.com/in/viebel/[LinkedIn]
- A pragmatic theorist
- Author of https://github.com/viebel/klipse[Klipse]
- A Web consultant: Full-Stack, clojure, clojurescript, node.js, react.js
- Blogger about Functional Programming (http://blog.klipse.tech/[blog.klipse.tech])
- Third year in a row at ClojureX
- Writing a book with Manning "Get Programming with Clojure" - MEAP launch today
--

image::images/me.jpg[me]


== Definitions and Rhetorics - Oxymoron


*Oxymoron*:

Figure of speech containing words that seem to contradict each other. 

[%step]
--
Examples:

- True myth
- Original copy
- Dark light
- Pragmatic theorist
--

[%step]
--
Purpose:

- Create a little bit of *drama* for the reader.
- Make a person stop and think, whether that's to *laugh* or to *wonder*.
--

[%step]
But it doesn't always work, because...

== Definitions and Rhetorics - Oxymoron

image::images/stone.jpg[stone]

== Definitions and Rhetorics - OOP vs. FP

[%step]
--
*Object Oriented Programming*:
A programming paradigm based on the concept of *objects*, which  contain:

- *data*, in the form of fields
- *code*, in the form of procedures, often known as methods.

Methods can access and [yellow-background]#often modify the data fields of the object# with which they are associated (objects have a notion of *this* or *self*).
--


[%step]
--
++++
<br>
<br>
++++

*Functional Programming*:
A programming paradigm based on the concept of *functions*, which receive *data* as arguments and return data.
A *function*:

- receives *data* and returns *data*
- [yellow-background]#avoids mutating *data*#

--


== Definitons and Rhetorics - Summary

[quote]
Is "functional object oriented programming" an oxymoron?


== Definitions and Rhetorics - OOP redefined

[%step]
--
*Object Oriented Programming*:
A programming paradigm based on the concepts of *objects* and *messages*.

An *object* includes:

- a package of data
- a description of the operations that can be performed on that data

A *message* specifies one of the operations, but unlike a procedure, does not describe how the operation should be carried out.
--



[%step]
--
++++
<br>
<br>
++++

*Functional Programming*:
A programming paradigm based on the concept of *functions*, which receive *data* as arguments and return data.
Functions avoid changing state and mutating data.
--




== Object oriented programming with maps

[%step]
--
What is a person?
--

[%step]
. A person has a firstname
. A person has a lastname
. A person drinks

== OOP with functions and maps

A "constructor" that returns a map with *data* and *operations*
[%step]
--
++++
<br>
++++
[source.clj]
----
(defn new-person [firstname lastname]
  {:data {:firstname firstname
          :lastname lastname
          :drinks []}
   :ops {:fullname (fn [this] "(fullname) will be implemented soon")
         :my-drinks (fn [this] "(my-drinks) will be implemented soon")
         :drink (fn [this a-drink] (str "(drink " a-drink "will be implemented soon"))}})
----
--

[%step]
--
At this stage, we can do two things:

. inspect the *data*
. send a *message*
--

[%step]
--
Inspecting the *data* is straightforward:
[source.clj]
----
(:data (new-person "dave" "smith"))
----
--

[%step]
--
To send a *message*, we need a utility function
[source.clj]
----
(defn send-msg [obj op-name & args]
  (let [op (get-in obj [:ops op-name])]
    (if op
      (apply op obj args)
      (str "no operation named: " op-name))))
----
--

[%step]
--
[source.clj]
----
(send-msg (new-person "dave" "smith") :fullname)
----
--

== OOP with function and maps - Operations

In order to implement *:fullname*, we need to:
[%step]

. Access _firstname_ and _lastname_ data fields
. Combine them

[%step]
--
First, the combinator

[source.clj]
----
(require '[clojure.string :refer [capitalize]])

(defn my-fullname [firstname lastname]
  (str (capitalize firstname) " " (capitalize lastname)))
----
--

[%step]
--
Now, the accessor
[source.clj]
----
(defn new-person-1 [firstname lastname]
  {:data {:firstname firstname
          :lastname lastname
          :drinks []}
   :ops {:fullname (fn [this]
                     (my-fullname (get-in this [:data :firstname])
                               (get-in this [:data :lastname])))
         :my-drinks (fn [this] "(my-drinks) will be implemented soon")
         :drink (fn [this a-drink] (str "(drink " a-drink "will be implemented soon"))}})
----
--

[%step]
--
Let's send a *:fullname* message to a person
[source.clj]
----
(send-msg (new-person-1 "dave" "smith") :fullname)
----
--


== More
[source.clj]
----
(defn new-doctor-compose [firstname lastname]
  {:person (new-person firstname lastname)
   :data nil
   :ops {:drinks (fn [this] (send-msg (:person this) :drinks))
         :drink (fn [this drink] (update this :person #(send-msg % :eat-drink drink)))
         :fullname (fn [this] (str "Dr. " (send-msg (:person this) :fullname)))}})
----

[source.clj]
----
(defn fullname [firstname lastname]
  (str (capitalize firstname) " " (capitalize lastname)))

(defn new-person [firstname lastname]
  {:data {:firstname firstname
          :lastname lastname
          :drinks []}
   :ops {:fullname (fn [this]
                     (fullname (get-in this [:data :firstname])
                               (get-in this [:data :lastname])))
         :drinks (fn [this] (get-in this [:data :drinks]))
         :drink (fn [this drink]
                  (update-in this [:data :drinks] #(conj % drink)))
         }})

(send-msg (new-person "dave" "smith") :fullname)
----
--
[%step]
--
++++
<br>
<br>
++++
How are we going to send a *message* to an *object*?
++++
<br>
<br>
++++

[%step]
--
[source.clj]
----
----
--


[%step]
--
++++
<br>
<br>
++++
Let's create an *object* and send it *messages*
++++
<br>
<br>
++++
--

[%step]
--
[source.clj]
----
(let [dave (new-person "Dave" 42)]
  (send-msg dave :age))
----
--

== OOP with maps - Messages with arguments


[%step]
--
[source.clj]
----
(defn new-person [name age]
  {:data {:name name
          :age age}
   :ops {:age (fn [this] (get-in this [:data :age]))
         :char-in-name (fn [this n] (nth (get-in this [:data :name]) n))
         :name (fn [this] (get-in this [:data :name]))}}) 
----
--

[%step]
--
++++
<br>
<br>
++++
How are we going to send a *message* with _arguments_ to an *object*?
--

[%step]
--
With _apply_ and _&_ of course!

[source.clj]
----
----
--


[%step]
--
++++
<br>
<br>
++++
Let's create an *object* and send it *messages* with arguments
++++
<br>
<br>
++++
--

[%step]
--
[source.clj]
----
(let [dave (new-person "Dave" 42)]
  (send-msg dave :char-in-name 0))
----
--



== OOP with maps

[%step]
--
We can create new functionalities outside of the objects.
--

[%step]
--
[source.clj]
----
(defn display [someone]
  (str (send-msg someone :name) " is "(send-msg someone :age) "."))
----
--

[%step]
--
++++
<br>
<br>
++++

We call *display* like a regular function.
No need to send a message.
Welcome to *Functional OOP*!


[source.clj]
----
(def j (new-person "Jennifer" 22))
(display j)
----
--

== OOP with maps - mutations?

[%step]
--
What about mutations? 
++++
<br>
<br>
++++
--

[%step]
--
image::images/mutation_is_bad.jpg[mutation, width=1000]
--

== OOP with maps - "mutations" first attemp

[%step]
--
Clojure is powerful: let's use atoms
++++
<br>
<br>
++++
--

[%step]
--
[source.clj]
----
(defn new-person-with-atoms [name age]
  {:data (atom {:name name
          :age age})
   :ops {:age (fn [this] (:age @(:data this)))
         :age! (fn [this age] 
                 (swap! (:data this) #(assoc % :age age))
                 this)
         :name (fn [this] (get-in this [:data :name]))}})
----
--

[%step]
--
++++
<br>
<br>
++++
Let's create an *object* and "mutate" it:

[source.clj]
----
(let [dave (new-person-with-atoms "Dave" 42)]
  (send-msg dave :age! 43)
  (display dave))
----
++++
<br>
<br>
++++
Victory? 
++++
--


== OOP with maps - "mutations"

[%step]
--
We have *assoc* and *assoc-in*!
++++
<br>
<br>
++++
--

[%step]
--
[source.clj]
----
(defn new-person-with-mutations [name age]
  {:data {:name name
          :age age}
   :ops {:age (fn [this] (get-in this [:data :age]))
         :age! (fn [this age] (assoc-in this [:data :age] age))
         :name (fn [this] (get-in this [:data :name]))}})
----
--

[%step]
--
++++
<br>
<br>
++++
Let's create an *object* and "mutate" it:

[source.clj]
----
(let [dave (new-person-with-mutations "Dave" 42)]
  (send-msg dave :age! 43)
  (display dave))
----
++++
<br>
<br>
++++
Oops
++++
--

== Definitions and Rhetorics - Oops

[quote]
--
Oops:
[%step]
. An exclamation used to show recognition of a mistake or minor accident, often as part of an apology.
[%step]
. (unused) Object Oriented Programming (OOP) plural form.
--



== OOP with maps - "mutations"

[%step]
--
[quote]
In Clojure, we never mutate an object, we create a new version of it!
--

[%step]
--
[source.clj]
----
(let [dave-42 (new-person-with-mutations "Dave" 42)
      dave-43 (send-msg a :age! 43)]
  (display dave-43))
----
--

== OOP with maps - Polymorphism

[%step]
--
Let's create another object that implements the same operations but behaves differently...
++++
<br>
++++
--
[%step]
--
[source.clj]
----
(defn new-doctor [name age]
  {:data {:name name
          :age age}
   :ops {:age (fn [this] (get-in this [:data :age]))
         :age! (fn [this age] (assoc-in this [:data :age] age))
         :name (fn [this] (str "Dr. " (get-in this [:data :name])))}})
----
--

[%step]
--
++++
<br>
<br>
++++
When we send a message, we don't know what procedure is going to be called
--

[%step]
--
The doctor:
[source.clj]
----
(let [dr-dave (new-doctor "Dave" 42)]
  (send-msg dr-dave :name))
----

The person:
[source.clj]
----
(let [dave (new-person-with-mutations "Dave" 42)]
      (send-msg dave :name))
----
++++
<br>
<br>
++++
Both pieces of code that send the message look the same, but the behaviour is different.
--

== OOP with maps - "Inheritance"

[%step]
--
No coupling between the operations and the object.
We can extract the operations from the object as regular functions.
--

[%step]
--
[source.clj]
----
(defn get-age [this]
  (get-in this [:data :age]))

(defn get-name [this]
  (get-in this [:data :name]))

(defn set-age! [this age]
  (assoc-in this [:data :age] age))

(defn new-person-inherit [name age]
  {:data {:name name
          :age age}
   :ops {:age get-age
         :age! set-age!
         :name get-name}})
----
--


[%step]
--
++++
<br>
<br>
++++
And "inherit" any function we want.
The doctor inherits *:age* and *:age!* and it overrides *:name*.
[source.clj]
----
(defn new-doctor-inherit [name age]
  {:data {:name name
          :age age}
   :ops {:age get-age
         :age! set-age!
         :name (fn [this] (str "Dr. " (get-in this [:data :name])))}})
----
--

[%step]
--
++++
<br>
<br>
++++
Let's test it:
[source.clj]
----
(let [dr-dave-42 (new-doctor-inherit "Dave" 42)
      dr-dave-88 (send-msg dr-dave-42 :age! 88)]
  (display dr-dave-88))
----
++++
<br>
<br>
++++
So far so good...
--


== OOP with maps - Composition

[%step]
--
We can even do composition.
A Doctor _isa_ Person or a Doctor _hasa_ Person?
--

[%step]
--
[source.clj]
----
(defn new-doctor-compose [name age]
  {:person (new-person-with-mutations name age)
   :data nil
   :ops {:age  (fn [this] (send-msg (:person this) :age))
         :age! (fn [this age] (update this :person #(send-msg % :age! age)))
         :name (fn [this] (str "Dr. " (send-msg (:person this) :name)))}})
----
--
[%step]
--
++++
<br>
<br>
++++
Let's test it:
[source.clj]
----
(let [dr-dave (new-doctor-compose "Dave" 42)]
  (display dr-dave))
----
--
[%step]
--
++++
<br>
<br>
++++
Let's change the age of the doctor:
[source.clj]
----
(let [dr-dave-42 (new-doctor-compose "Dave" 42)
      dr-dave-88 (send-msg dr-dave-42 :age! 88)]
  (display dr-dave-88))
----
++++
<br>
<br>
++++
--
[%step]
--
It works but it becomes a bit complicated
--




== Definitions and Rhetorics - Functional OOP

[%step]
--
*Functional Object Oriented Programming*:
A programming paradigm based on the concepts of *functions*, *objects* and *messages*.


A *function*:

- receives *data* and returns *data*
- avoids mutating *data*

An *object* includes:

- a package of *data*
- a description of the operations that can be performed on that *data*
- [yellow-background]#an operation avoids mutating data: it eithers returns *data* or a *new version* of the object#

A *message* specifies one of the operations without describing how the operation should be carried out.
--

== Functional OOP with Records

First, we define a protocol and a display function:

[%step]
--
++++
<br>
++++
[source.clj]
----
(defprotocol IPerson
  (age [this])
  (age! [this age])
  (fullname [this]))

(defn display-person [person]
  (str (fullname person) " is " (age person)))
----
--

[%step]
--
++++
<br>
<br>
++++
Then, a record that implements the protocol:
[source.clj]
----
(defrecord Person [firstname lastname age]
  IPerson
  (age [this] age)
  (age! [this new-age] (assoc this :age new-age))
  (fullname [this] (str firstname " " lastname)))
----
--

[%step]
--
++++
<br>
<br>
++++
And a constructor
[source.clj]
----
(defn create-person [firstname lastname age]
  (Person. firstname lastname age))
----
--

[%step]
--
++++
<br>
<br>
++++
Let's create and display a person
[source.clj]
----
(display-person  (create-person "Dave" "Smith" 42)) 
----
--

== Functional OOP with Records - why constructors

[%step]
--
++++
<br>
<br>
++++
Do we really need a constructor?
--

[%step]
--
image::images/indirection.jpg[mutation, width=1000]
--


== Functional OOP in Clojure - Records are wacky maps

[%step]
--
++++
<br>
++++

Records look like maps

[source.clj]
----
(Person. "Dave" "Smith" 42)
----
++++
--

[%step]
--
++++
<br>
++++
They have keys

[source.clj]
----
(keys (Person. "Dave" "Smith" 42))
----
++++
--

[%step]
--
++++
<br>
++++
keys are functions

[source.clj]
----
(:age (Person. "Dave" "Smith" 42))
----
++++
--

[%step]
--
++++
<br>
++++

[red]#But records are not functions#

[source.clj]
----
(keys (Person. "Dave" "Smith" 42))
----
++++
--

[%step]
--
++++
<br>
++++
You can assoc them

[source.clj]
----
(assoc (Person. "Dave" "Smith" 42) :age 88)
----
++++
--

[%step]
--
++++
<br>
++++
[red]#But be careful when you dissoc them#

[source.clj]
----
(fullname (dissoc (Person. "Dave" "Smith" 42) :age))
----
++++
--

== Functional OOP with Records - why setters and getters?

[%step]
--
++++
<br>
++++
Do we really need *age* and *age!*?
--

[%step]
--
image::images/indirection.jpg[mutation, width=1000]
--


== Functional OOP with Records - composition

[%step]
--
[source.clj]
----
(defrecord Doctor [person]
  IPerson
  (age [this] (age person))
  (age! [this new-age] (update this :person #(age! % new-age)))
  (fullname [this] (str "Dr. " (:firstname person) " " (:lastname person))))
----
--

[%step]
--
++++
<br>
<br>
++++
[source.clj]
----
(defn create-doctor [firstname lastname age]
  (Doctor. (Person. firstname lastname age)))
----
--


[%step]
--
++++
<br>
<br>
++++
[source.clj]
----
(display-person (age! (create-doctor "Dave" "Smith" 42) 88))  
----
--

== One last thing

[%step]
--
In Clojure, everything can behave like a function
--

[%step]
--
[source.clj]
----
(extend-type Person
  IFn
  (-invoke
    ([this key]
     (get this key))))
----
--

[%step]
--
[source.clj]
----
((create-person "Dave" "Smith" 42) :age)
----
--

[%step]
--
Functions and maps emulate OOP
Functions are protocols
Circle diagram 
--

== Conclusion

What is the essence of Clojure?

[%step]

- LISP syntax ?
- Functional programming ?
- Immutability ?


== Questions

image::images/questions.jpg[questions]


== Maybe

[source.clj]
----

(defn new-person-maybe [{:keys [firstname lastname languages fruits]
                   :as data
                   :or {languages #{} fruits []}}]
  {:data (assoc data :languages languages :fruits fruits)
   :ops {:full-name (fn [this] (str (capitalize firstname) " " (capitalize lastname)))
         :add-language (fn [this language] 
                         (update-in this [:data :languages] #(conj % language)))
         :eat-fruit (fn [this fruit] 
                         (update-in this [:data :fruits] #(conj % fruit)))
                       }}) 



(-> (new-person-maybe {:firstname "dave" :lastname "smith"})
    (send-msg :add-language "fr")
    (send-msg :add-language "en") 
    (send-msg :eat-fruit "orange")
    (send-msg :eat-fruit "orange")
    (send-msg :eat-fruit "banana")

    :data
    )      
----
++++
<style>
.yellow-background {
background: yellow;
}
.red {
color: red;
}
</style>
++++

++++
<style>
.CodeMirror {
    border: solid 2px #90B4FE !important;
    width: 80%;
    left: 10%;
    font-size: 24px;
}

.klipse-container {
    margin-bottom: 10px;
    left: 12%;
    position: absolute;
}

.vertical-padder {
height: 40vh;
}
</style>
++++

include::klipse.adoc[]