= Polymorphism Ã  la Clojure: Functional Object Oriented Programming is not an Oxymoron
:encoding: utf-8
:navigation:
:deckjs_transition: horizontal-slide
:menu:
:status:
:deckjs_theme: none
:hardbreaks:

++++
<pre class="hidden"><code class="clj">
(ns my.playground)
</code></pre>
++++


== Intro

++++
<section class="slide">
        <div class="text-centered">
            <div class="centered" style="font-size:1.9em;">
              <div class="left" style="width:50%;">
	      <img src='https://chart.googleapis.com/chart?cht=qr&chl=http%3A%2F%2Fslides.klipse.tech%2Fasciidoc%2Ffunctional-oop-clojure.html&chs=300x300' alt='qr code'></img>
	      </div>
              <div class="left" style="width:50%;">
		<div>
                  <div>
                    <img class="fullscreen" src="./images/klipse.png" alt="" width="150">
                  </div> 
                  <div>
		  <div>ClojureX 2017</div>
		  <div>London - Dec 4, 2017</div>
                  </div>
                  <div class="clear">
                    <div style="margin-top:14px;">
		    <a class="github-button" href="https://github.com/viebel/klipse" data-size="large" data-show-count="true" aria-label="Star viebel/klipse on GitHub">Klipse</a>
                    </div>
                  </div>
                  <div>
		  <a href="https://tinyurl.com/fun-oop"> https://tinyurl.com/fun-oop </a>
                  </div>
		</div>
              </div>
            </div>
            <div class="clear centered">
	    <br><br><br>
	      <div style="padding-top: 20px;">
		<pre><code class="clj" data-loop-msec="1000" data-beautify-strings="true">
		(str (js/Date.))
		</code></pre>
		<br>
	      </div>
            </div>
	    <br><br>
	    <div style="font-size: 2em;">Yehonathan Sharvit</div>
	    <div style="font-size: 2em;"> <a href="https://twitter.com/viebel">@viebel</a>, viebel@gmail.com</div></p>
        </div>
      </section>
++++

== The Agenda

- Definitions and Rhetorics
- Object oriented with maps
- Object oriented with multimethods
- Object oriented with records
- The expression problem
- Functions as protocols
- Conclusion

== Who am I?
[.left]
--
- Yehonathan Sharvit https://twitter.com/viebel[@viebel], viebel@gmail.com, https://www.linkedin.com/in/viebel/[LinkedIn]
- A mathematician
- A coder
- A pragmatic theorist
- Author of https://github.com/viebel/klipse[Klipse] - a simple client-side code evaluator pluggable on any web page 
- A Web consultant: Full-Stack, clojure, clojurescript, javascript, node.js, react
- Blogger about functional programming at http://blog.klipse.tech/[blog.klipse.tech]
- Third year in a row at ClojureX
- Writing a book with Manning "Get Programming with Clojure"
--

image::images/me.jpg[me]


== Definitions and Rhetorics - Oxymoron

[quote]
Oxymoron: Figure of speech containing words that seem to contradict each other. 

[%step]
--
Examples:

- True myth
- Original copy
- Dark light
- Pragmatic theorist
--

[%step]
--
Purpose:

- Create a little bit of drama for the reader.
- Make a person stop and think, whether that's to laugh or to wonder.
--

[%step]
But...

== Definitions and Rhetorics - Oxymoron

image::images/stone.jpg[stone]

== Definitions and Rhetorics - Object Oriented Programming

[quote]
OOP: A programming paradigm based on the concept of *objects*, which  contain *data*, in the form of fields; and *code*, in the form of procedures, often known as methods.
Methods can access and often modify the data fields of the object with which they are associated (objects have a notion of _this_ or _self_).

== Definitions and Rhetorics - Functional Programming

[quote]
FP: A programming paradigm based on the concept of *functions*, which receive *data* as arguments and return data.
Functions avoid changing state and mutating data.


== Definitons and Rhetorics - summary

[quote]
Is functional object oriented programming an oxymoron?


== Definitions and Rhetorics - OOP redefined

[quote]
--
OOP: A programming paradigm in which the concepts of *procedures* and *tasks* are replaced by the concepts of *objects* and *messages*.

An *object* includes:

- a package of data
- a description of the operations that can be performed on that data

A *message* specifies one of the operations, but unlike a procedure, does not describe how the operation should be carried out.
--

== Object oriented programming with maps

[%step]
--

A "constructor"...
++++
<br>
++++

[source.clj]
----
(defn new-person [name age]
  {:data {:name name
          :age age}
   :ops {:age (fn [this] (get-in this [:data :age]))
         :name (fn [this] (get-in this [:data :name]))}})
----
--
[%step]
--
++++
<br>
<br>
++++
How are we going to send a *message* to an *object*?
++++
<br>
<br>
++++
--

[%step]
--
[source.clj]
----
(defn send-msg [obj name]
  (let [op (get-in obj [:ops name])]
    (op obj)))
----
--

[%step]
--
++++
<br>
<br>
++++
Let's create an *object* and send it *messages*
++++
<br>
<br>
++++
--

[%step]
--
[source.clj]
----
(def a (new-person "Dave" 42))
(send-msg a :age) 
----
--

== OOP with maps

[%step]
--
We can create new functionalities outside of the objects.
--

[%step]
--
[source.clj]
----
(defn display [someone]
  (str (send-msg someone :name) " is "(send-msg someone :age) "."))
(display a)
----
--

== OOP with maps - mutations?

[%step]
--
What about mutations? 
++++
<br>
<br>
++++
--

[%step]
--
image::images/mutation.png[mutation, width=1000]
--

== OOP with maps - "mutations"

[%step]
--
We have *assoc* and *assoc-in*!
++++
<br>
<br>
++++
--

[%step]
--
[source.clj]
----
(defn new-person-with-mutations [name age]
  {:data {:name name
          :age age}
   :ops {:age (fn [this] (get-in this [:data :age]))
         :age! (fn [this age] (assoc-in this [:data :age] age))
         :name (fn [this] (get-in this [:data :name]))}})
----
--

[%step]
--
++++
<br>
<br>
++++
How are we going to send a *message* with _arguments_ to an *object*?
--

[%step]
--
With _apply_ and _&_ of course!

[source.clj]
----
(defn send-msg [obj name & args]
  (let [op (get-in obj [:ops name])]
    (apply op obj args)))
----
--

[%step]
--
++++
<br>
<br>
++++
Let's create an *object* and "mutate" it:

[source.clj]
----
(def a (new-person-with-mutations "Dave" 42))
(send-msg a :age! 43)
(send-msg a :age)
----
++++
<br>
<br>
++++
Oops
++++
--

== Definitions and Rhetorics - Oops

[quote]
--
Oops:
1. An exclamation used to show recognition of a mistake or minor accident, often as part of an apology.
2. (unused) Object Oriented Programming (OOP) plural form.
--

== OOP with maps - "mutations"

[%step]
--
[quote]
In Clojure, we never mutate an object, we create a new version of it!
--

[%step]
--
[source.clj]
----
(def aa (new-person-with-mutations "Dave" 42))
(def bb (send-msg a :age! 43))
(display bb)
----
--

== OOP with maps - Polymorphism

[%step]
--
Let's create another object that implements the same operations but behaves differently...
++++
<br>
++++
--
[%step]
--
[source.clj]
----
(defn new-doctor [name age]
  {:data {:name name
          :age age}
   :ops {:age (fn [this] (get-in this [:data :age]))
         :age! (fn [this age] (assoc-in this [:data :age] age))
         :name (fn [this] (str "Dr. " (get-in this [:data :name])))}})
----
--

[%step]
--
++++
<br>
<br>
++++
When we send a message, we don't know what procedure is going to be called
--

[%step]
--
The doctor:
[source.clj]
----
(def dd (new-doctor "Dave" 42))
(send-msg dd :name)
----

The person:
[source.clj]
----
(def ee (new-person-with-mutations "Dave" 42))
(send-msg ee :name)
----
++++
<br>
<br>
++++
Both pieces of code that send the message look the same, but the behaviour is different.
--

== OOP with maps - "Inheritance"

[%step]
--
No coupling between the operations and the object.
We can extract the operations from the object as regular functions.
--

[%step]
--
[source.clj]
----
(defn get-age [this]
  (get-in this [:data :age]))

(defn get-name [this]
  (get-in this [:data :name]))

(defn set-age! [this age]
  (assoc-in this [:data :age] age))

(defn new-person-inherit [name age]
  {:data {:name name
          :age age}
   :ops {:age get-age
         :age! set-age!
         :name get-name}})
----
--


[%step]
--
++++
<br>
<br>
++++
And "inherit" any function we want.
The doctor inherits *:age* and *:age!* and it overrides *:name*.
[source.clj]
----
(defn new-doctor-inherit [name age]
  {:data {:name name
          :age age}
   :ops {:age get-age
         :age! set-age!
         :name (fn [this] (str "Dr. " (get-in this [:data :name])))}})
----
--

[%step]
--
++++
<br>
<br>
++++
Let's test it:
[source.clj]
----
(def ddd (new-doctor-inherit "Dave" 42))
(display ddd)
----
++++
<br>
<br>
++++
[source.clj]
----
(def eee (send-msg ddd :age! 88))
(display eee)
----
++++
<br>
<br>
++++
So far so good...
--


== OOP with maps - Composition

[%step]
--
We can even do composition.
A Doctor _isa_ Person or a Doctor _hasa_ Person?
--

[%step]
--
[source.clj]
----
(defn new-doctor-compose [name age]
  {:person (new-person-with-mutations name age)
   :data nil
   :ops {:age  (fn [this] (send-msg (:person this) :age))
         :age! (fn [this age] (update this :person #(send-msg % :age! age)))
         :name (fn [this] (str "Dr. " (send-msg (:person this) :name)))}})
----
--
[%step]
--
++++
<br>
<br>
++++
Let's test it:
[source.clj]
----
(def dddd (new-doctor-compose "Dave" 42))
(display dddd)
----
--
[%step]
--
++++
<br>
<br>
++++
Let's change the age of the doctor.
[source.clj]
----
(def eeee (send-msg dddd :age! 88))
(display eeee)
----
++++
<br>
<br>
++++
--
[%step]
--
It works but it becomes a bit complicated
--




== Questions

image::images/questions.jpg[questions]




++++
<style>
.CodeMirror {
    border: solid 2px #90B4FE !important;
    width: 80%;
    left: 10%;
    font-size: 24px;
}

.klipse-container {
    margin-bottom: 10px;
    left: 12%;
    position: absolute;
}

.vertical-padder {
height: 40vh;
}
</style>
++++

include::klipse.adoc[]