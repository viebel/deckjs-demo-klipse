= Polymorphism à la Clojure: "Functional Object Oriented Programming" is not an Oxymoron
:encoding: utf-8
:navigation:
:deckjs_transition: horizontal-slide
:menu:
:status:
:deckjs_theme: none
:hardbreaks:

++++
<pre class="hidden"><code class="clj">
(ns my.playground)
</code></pre>
++++


== Intro

++++
<section class="slide">
        <div class="text-centered">
            <div class="centered" style="font-size:1.9em;">
	    <br>
            <div> Polymorphism à la Clojure
    <br>
    <span style="font-style:italic;m">Functional Object Oriented Programming</span>
    <br>
    is not an Oxymoron
    </div>
              <div class="left" style="width:50%;">
	      <img src='https://chart.googleapis.com/chart?cht=qr&chl=http%3A%2F%2Fslides.klipse.tech%2Fasciidoc%2Ffunctional-oop-clojure.html&chs=300x300' alt='qr code'></img>
	      </div>
              <div class="left" style="width:50%;">
		<div>
                  <div>
                    <img class="fullscreen" src="./images/klipse.png" alt="" width="150">
                  </div> 
                  <div>
		  <div>ClojureX 2018</div>
		  <div>London - Dec 3, 2018</div>
                  </div>
                  <div class="clear">
                    <div style="margin-top:14px;">
		    <a class="github-button" href="https://github.com/viebel/klipse" data-size="large" data-show-count="true" aria-label="Star viebel/klipse on GitHub">Klipse</a>
                    </div>
                  </div>
                  <div>
		  <a href="https://tinyurl.com/fun-oop"> https://tinyurl.com/fun-oop </a>
                  </div>
		</div>
              </div>
            </div>
            <div class="clear centered">
	    <br><br><br>
	      <div style="padding-top: 20px;">
		<pre><code class="clj" data-loop-msec="1000" data-beautify-strings="true">
		(str (js/Date.))
		</code></pre>
		<br>
	      </div>
            </div>
	    <br><br>
	    <div style="font-size: 2em;">Yehonathan Sharvit</div>
	    <div style="font-size: 2em;"> <a href="https://twitter.com/viebel">@viebel</a>, viebel@gmail.com</div></p>
        </div>
      </section>
++++

== The Agenda

- Definitions and Rhetorics
- Object Oriented Programming with functions and maps
- Object Oriented Programming with records and protocols
- Conclusion

https://clojure.org/reference/datatypes#_deftype_and_defrecord

== Who am I?
[.left]
--
- Yehonathan Sharvit https://twitter.com/viebel[@viebel], viebel@gmail.com, https://www.linkedin.com/in/viebel/[LinkedIn]
- A pragmatic theorist
- Author of https://github.com/viebel/klipse[Klipse]
- A Web consultant: Full-Stack, clojure, clojurescript, node.js, react.js
- A disciple of the Bible
- A Blogger about Functional Programming (http://blog.klipse.tech/[blog.klipse.tech])
- Third year in a row at ClojureX
- Writing a book with Manning "Get Programming with Clojure" - MEAP launch today
--

image::images/me.jpg[me]


== Definitions and Rhetorics - Oxymoron


*Oxymoron*:

Figure of speech containing words that seem to contradict each other. 

[%step]
--
Examples:

- True myth
- Original copy
- Dark light
- Pragmatic theorist
--

[%step]
--
Purpose:

- Create a little bit of *drama* for the reader.
- Make a person stop and think, whether that's to *laugh* or to *wonder*.
--

[%step]
But it doesn't always work, because...

== Definitions and Rhetorics - Oxymoron

image::images/stone.jpg[stone]

== Definitions and Rhetorics - OOP vs. FP

[%step]
--
*Object Oriented Programming*:
A programming paradigm based on the concept of *objects*, which  contain:

- *data*, in the form of fields
- *code*, in the form of procedures, often known as methods.

Methods can access and [yellow-background]#often modify the data fields of the object# with which they are associated (objects have a notion of *this* or *self*).
--


[%step]
--
++++
<br>
<br>
++++

*Functional Programming*:
A programming paradigm based on the concept of *functions*, which receive *data* as arguments and return data.
A *function*:

- receives *data* and returns *data*
- [yellow-background]#avoids mutating *data*#

--


== Definitons and Rhetorics - Summary

[quote]
Is "functional object oriented programming" an oxymoron?


== Definitions and Rhetorics - OOP redefined

[%step]
--
*Object Oriented Programming*:
A programming paradigm based on the concepts of *objects* and *messages*.

An *object* includes:

- a package of data
- a description of the operations that can be performed on that data

A *message* specifies one of the operations, but unlike a procedure, does not describe how the operation should be carried out.
--



[%step]
--
++++
<br>
<br>
++++

*Functional Programming*:
A programming paradigm based on the concept of *functions*, which receive *data* as arguments and return data.
Functions avoid changing state and mutating data.
--


== Functional OOP - The 5 commandments 

[bible]
--
. Thou Shalt Not Encapsulate Information

. Thou Shalt Not Mutate an Object

. Let Thy Friend Extend a Class as Thyself

. Thou Shalt Only Program to an Interface

. Thou Shalt Not Derive from a Concrete Class
--


== Application of the commandements

[%step]
--
[bible]#Then God said, “Let us make *mankind* in our image, in our likeness, so that they may follow my *commandements* to modelize the fish in the sea and the birds in the sky, over the livestock and all the wild animals, and over all the creatures that move along the ground.”# (Genesis, Chapter 1 - revised)
--


== Object oriented programming with maps

[%step]
--
What is the essence of a human?
--

[%step]
. A human has a name
. A human has an appellation - how other humans refer to him
. A human can drink
. When a human drinks too much, he is drunk


add image of drunk biblical human

== OOP with functions and maps

A "constructor" that returns a map with *data* and *operations*
[%step]
--
++++
<br>
++++
[source.clj]
----
(defn new-human-0 [name]
  {:data {:name name
          :drinks 0}
   :ops {:appellation (fn [this] "(:appellation will be implemented soon")
         :take-some-drinks (fn [this how-many] (str "(:take-some-drinks " how-many ") will be implemented soon"))
         :drunk? (fn [this] "(:drunk? will be implemented soon")}})
----
--

[%step]
--
How does the first human being look like? 
[source.clj]
----
(new-human-0 "Adam")
----
--


[%step]
--
*Data* inspection is trivial
[source.clj]
----
(:data (new-human-0 "Adam"))
----
--

[%step]
--
To send a *message*, we retrieve the function from the *:ops* map and call it with the _object_ and the _args_.
[source.clj]
----
(defn send-msg [obj op-name & args]
  (let [op (get-in obj [:ops op-name])]
    (if op
      (apply op obj args)
      (str "no operation named: " op-name))))
----
--

[%step]
--
Let's ask Adam to take a drink
--

[%step]
--
[source.clj]
----
(send-msg (new-human-0 "Adam") :take-some-drinks 1)
----
--


== OOP with function and maps - Queries

[%step]
--
Queries are easy

[source.clj]
----
(defn new-human-1 [name]
  {:data {:name name
          :drinks 0}
   :ops {:appellation (fn [this] (get-in this [:data :name]))
         :take-some-drinks (fn [this how-many] (str "(:take-some-drinks " how-many ") will be implemented soon"))
         :drunk? (fn [this] (> (get-in this [:data :drinks]) 3))}})
----
--

[%step]
--
Let's send a *:appellation* message to a human
[source.clj]
----
(send-msg (new-human-1 "Adam") :appellation)
----
--


[%step]
--
We can still inspect the data
[source.clj]
----
(inspect-data (new-human-1 "Adam") :name)
----
--

[%step]
--
++++
<br>
<br>
++++
[meditation]#Why do we need both *:appellation* operation and *:name* field?#
--


== OOP with maps - mutations

[%step]
--
What about mutations? 
++++
<br>
<br>
++++
--

[%step]
--
image::images/mutation_is_bad.jpg[mutation, width=1000]
--

== OOP with maps - "mutations" first attemp

[%step]
--
Clojure is powerful: let's use atoms
++++
<br>
<br>
++++
--

[%step]
--
[source.clj]
----
(defn new-human-with-atoms [name]
  {:data {:name name
          :drinks (atom 0)}
   :ops {:appellation (fn [this] (get-in this [:data :name]))
         :take-some-drinks (fn [this how-many]
                             (swap! (get-in this [:data :drinks]) (partial + how-many))
                             this)
         :drunk? (fn [this] (> @(get-in this [:data :drinks]) 3))}})
----
--

[%step]
--
++++
<br>
<br>
++++
Let's ask Noah to take a couple of drinks

[source.clj]
----
(let [noah (new-human-with-atoms "Noah")]
  #_(send-msg noah :take-some-drinks 1)
    #_(send-msg noah :take-some-drinks 1)
      #_(send-msg noah :take-some-drinks 1)
        #_(send-msg noah :take-some-drinks 1)
	  (send-msg noah :drunk?))
----
--
++++
<br>
<br>
++++
[%step]
--
That's not what we are looking for:

. Now, we have different states for *Noah*
. We have violated Commandment #2 "Thou Shalt Not Mutate an Object"

--

== OOP with functions and maps

After a drink, a human is not the same human



== OOP with maps - changes without mutations

[%step]
--
We have *update-in*
++++
<br>
<br>
++++
--

[%step]
--
[source.clj]
----
(defn new-human [name]
  {:data {:name name
          :drinks 0}
   :ops {:appellation (fn [this] (get-in this [:data :name]))
         :drunk? (fn [this] (> (get-in this [:data :drinks]) 3))
         :take-some-drinks (fn [this how-many]
                             (update-in this
                                        [:data :drinks]
                                        (partial + how-many)))}})
----
--

[%step]
--
++++
<br>
<br>
++++
Let's create an *object* and "mutate" it:

[source.clj]
----
(let [abraham (new-human "Abraham")]
  #_(send-msg abraham :take-some-drinks 1)
    #_(send-msg abraham :take-some-drinks 1)
      #_(send-msg abraham :take-some-drinks 1)
        #_(send-msg abraham :take-some-drinks 1)
	    (send-msg abraham :drunk?))
----
++++
<br>
<br>
++++
Abraham looks much more resistant to alcohol than Noah!
++++
--

[%step]
--
++++
<br>
<br>
++++
Let's explore the data

[source.clj]
----
(let [abraham (new-human "King Abraham")]
  (send-msg abraham :take-some-drinks 1)
    (send-msg abraham :take-some-drinks 1)
      (send-msg abraham :take-some-drinks 1)
        (send-msg abraham :take-some-drinks 1)
	  (:data abraham))
----
--

[%step]
--
[source.clj]
----
(let [abraham (new-human "Abraham")
      abraham-1 (send-msg abraham :take-some-drinks 1)
            abraham-2 (send-msg abraham-1 :take-some-drinks 1)
	          abraham-3 (send-msg abraham-2 :take-some-drinks 1)
		        abraham-4 (send-msg abraham-3 :take-some-drinks 1)]
			  (send-msg abraham-4 :drunk?))
----
--

[%step]
--
A shorter version of it
[source.clj]
----
(-> (new-human "Abraham")
    (send-msg :take-some-drinks 2)
    (send-msg :take-some-drinks 3)
    (send-msg :status))
----
--
== Functional OOP - extension

[%step]
--
[source.clj]
----
(defn new-human-with-status [name]
  (let [human (new-human name)]
    (assoc-in human [:ops :status]
              (fn [this]
                (let [name (get-in this [:data :name])
                      drinks (get-in this [:data :drinks])]
                  (str name " has drunk " drinks " drinks"))))))
----
--


[%step]
--
++++
<br>
<br>
++++

Let's check Joseph's status after a couple of drinks


[source.clj]
----
(-> (new-human-with-status "Joseph")
    (send-msg :take-some-drinks 2)
    (send-msg :take-some-drinks 3)
    (send-msg :status))
----
--


== OOP with maps - Polymorphism

[%step]
--
Let's create another object that implements the same operations but behaves differently...
++++
<br>
++++
--
[%step]
--
[source.clj]
----
(defn new-king [name]
  {:data {:name name
          :drinks 0}
   :ops {:appellation (fn [this] (str "King " (get-in this [:data :name])))
         :drunk? (fn [this] (> (get-in this [:data :drinks]) 3))
         :take-some-drinks (fn [this how-many]
                             (update-in this
                                        [:data :drinks]
                                        (partial + how-many)))}})
----
--

[%step]
--
++++
<br>
<br>
++++
When we send a message, we don't know what procedure is going to be called
--

[%step]
--
David, the king
[source.clj]
----
(let [david (new-king "David")] 
  (send-msg david :appellation))
----

David, the human
[source.clj]
----
(let [david (new-human "David")] 
  (send-msg david :appellation))
----
++++
<br>
<br>
++++
Both pieces of code that send the message look the same, but the behaviour is different.
--

== Definitions and Rhetorics - Functional OOP

[%step]
--
*Functional Object Oriented Programming*:
A programming paradigm based on the concepts of *functions*, *objects* and *messages*.


A *function*:

- receives *data* and returns *data*
- avoids mutating *data*

An *object* includes:

- a package of *data*
- a description of the operations that can be performed on that *data*
- [yellow-background]#an operation avoids mutating data: it eithers returns *data* or a *new version* of the object#

A *message* specifies one of the operations without describing how the operation should be carried out.
--

== Functional OOP with Records

First, we define a protocol and a display function:

[%step]
--
++++
<br>
++++
[source.clj]
----
(defprotocol IHuman
  (age [this])
  (age! [this age])
  (fullname [this]))

(defn display-human [human]
  (str (fullname human) " is " (age human)))
----
--

[%step]
--
++++
<br>
<br>
++++
Then, a record that implements the protocol:
[source.clj]
----
(defrecord Human [firstname lastname age]
  IHuman
  (age [this] age)
  (age! [this new-age] (assoc this :age new-age))
  (fullname [this] (str firstname " " lastname)))
----
--

[%step]
--
++++
<br>
<br>
++++
And a constructor
[source.clj]
----
(defn create-human [firstname lastname age]
  (Human. firstname lastname age))
----
--

[%step]
--
++++
<br>
<br>
++++
Let's create and display a human
[source.clj]
----
(display-human  (create-human "Dave" "Smith" 42)) 
----
--

== Functional OOP with Records - why constructors

[%step]
--
++++
<br>
<br>
++++
Do we really need a constructor?
--

[%step]
--
image::images/indirection.jpg[mutation, width=1000]
--


== Functional OOP in Clojure - Records are wacky maps

[%step]
--
++++
<br>
++++

Records look like maps

[source.clj]
----
(Human. "Dave" "Smith" 42)
----
++++
--

[%step]
--
++++
<br>
++++
They have keys

[source.clj]
----
(keys (Human. "Dave" "Smith" 42))
----
++++
--

[%step]
--
++++
<br>
++++
keys are functions

[source.clj]
----
(:age (Human. "Dave" "Smith" 42))
----
++++
--

[%step]
--
++++
<br>
++++

[red]#But records are not functions#

[source.clj]
----
(keys (Human. "Dave" "Smith" 42))
----
++++
--

[%step]
--
++++
<br>
++++
You can assoc them

[source.clj]
----
(assoc (Human. "Dave" "Smith" 42) :age 88)
----
++++
--

[%step]
--
++++
<br>
++++
[red]#But be careful when you dissoc them#

[source.clj]
----
(fullname (dissoc (Human. "Dave" "Smith" 42) :age))
----
++++
--

== Functional OOP with Records - why setters and getters?

[%step]
--
++++
<br>
++++
Do we really need *age* and *age!*?
--

[%step]
--
image::images/indirection.jpg[mutation, width=1000]
--


== Functional OOP with Records - composition

[%step]
--
[source.clj]
----
(defrecord Doctor [human]
  IHuman
  (age [this] (age human))
  (age! [this new-age] (update this :human #(age! % new-age)))
  (fullname [this] (str "Dr. " (:firstname human) " " (:lastname human))))
----
--

[%step]
--
++++
<br>
<br>
++++
[source.clj]
----
(defn create-doctor [firstname lastname age]
  (Doctor. (Human. firstname lastname age)))
----
--


[%step]
--
++++
<br>
<br>
++++
[source.clj]
----
(display-human (age! (create-doctor "Dave" "Smith" 42) 88))  
----
--

== One last thing

[%step]
--
In Clojure, everything can behave like a function
--

[%step]
--
[source.clj]
----
(extend-type Human
  IFn
  (-invoke
    ([this key]
     (get this key))))
----
--

[%step]
--
[source.clj]
----
((create-human "Dave" "Smith" 42) :age)
----
--

[%step]
--
Functions and maps emulate OOP
Functions are protocols
Circle diagram 
--

== Conclusion

What is the essence of Clojure?

[%step]

- LISP syntax ?
- Functional programming ?
- Immutability ?


== Questions

image::images/questions.jpg[questions]


== Maybe

[source.clj]
----

(defn new-human-maybe [{:keys [firstname lastname languages fruits]
                   :as data
                   :or {languages #{} fruits []}}]
  {:data (assoc data :languages languages :fruits fruits)
   :ops {:full-name (fn [this] (str (capitalize firstname) " " (capitalize lastname)))
         :add-language (fn [this language] 
                         (update-in this [:data :languages] #(conj % language)))
         :eat-fruit (fn [this fruit] 
                         (update-in this [:data :fruits] #(conj % fruit)))
                       }}) 



(-> (new-human-maybe {:firstname "dave" :lastname "smith"})
    (send-msg :add-language "fr")
    (send-msg :add-language "en") 
    (send-msg :eat-fruit "orange")
    (send-msg :eat-fruit "orange")
    (send-msg :eat-fruit "banana")

    :data
    )      
----
++++
<style>
.bible {
font-family: cursive;
font-size: 2.5em;
}
.yellow-background {
background: yellow;
}
.red {
color: red;
}
</style>
++++

++++
<style>
.CodeMirror {
    border: solid 2px #90B4FE !important;
    width: 80%;
    left: 10%;
    font-size: 24px;
}

.klipse-container {
    margin-bottom: 10px;
    left: 12%;
    position: absolute;
}

.vertical-padder {
height: 40vh;
} 
</style>
++++

include::klipse.adoc[]